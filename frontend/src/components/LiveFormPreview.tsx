import React, { useState, useEffect, useRef } from 'react';
import { EmbeddableForm } from './EmbeddableForm';
import { FormData, GeneratedForm, SaaSForm, FormField } from '../types/api';
import { CheckCircle } from 'lucide-react'; // Import CheckCircle icon

// Helper to determine if a color is light (simplified for demo)
const isLightColor = (color: string): boolean => {
  if (!color) return false;
  let r, g, b;

  // Handle hex colors
  if (color.startsWith('#')) {
    const hex = color.slice(1);
    if (hex.length === 3) { // #rgb
      r = parseInt(hex[0] + hex[0], 16);
      g = parseInt(hex[1] + hex[1], 16);
      b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length === 6) { // #rrggbb
      r = parseInt(hex.substring(0, 2), 16);
      g = parseInt(hex.substring(2, 4), 16);
      b = parseInt(hex.substring(4, 6), 16);
    } else {
      return false;
    }
  } 
  // Handle rgb/rgba colors
  else if (color.startsWith('rgb')) {
    const parts = color.match(/\d+/g)?.map(Number);
    if (parts && parts.length >= 3) {
      [r, g, b] = parts;
    } else {
      return false;
    }
  }
  // Handle hsl/hsla colors
  else if (color.startsWith('hsl')) {
    // For simplicity, treat HSL as dark if lightness is low
    const lightnessMatch = color.match(/hsla?\(\s*\d+\s*,\s*\d+%\s*,\s*(\d+)%\s*(?:,\s*\d*\.?\d+)?\)/);
    if (lightnessMatch && lightnessMatch[1]) {
      const lightness = parseInt(lightnessMatch[1]);
      return lightness > 70; // Arbitrary threshold for light HSL
    }
    return false;
  }
  else {
    return false; // Not a recognized color format
  }

  // Calculate luminance (simplified)
  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return luminance > 0.7; // Threshold for "light"
};

interface LiveFormPreviewProps {
  formData: Partial<FormData>;
  generatedForm: GeneratedForm | null;
  createdForm: SaaSForm | null;
  user?: any;
  extractedDesignTokens: any | null;
  extractedVoiceAnalysis: any | null;
}

export const LiveFormPreview: React.FC<LiveFormPreviewProps> = ({
  formData,
  generatedForm,
  createdForm,
  user,
  extractedDesignTokens, // Use new prop
  extractedVoiceAnalysis, // Use new prop
}) => {
  const { url, purpose, destinationType } = formData;

  const previewContainerRef = useRef<HTMLDivElement>(null); // Ref for the fixed-height container
  const formNaturalSizeRef = useRef<HTMLDivElement>(null); // Ref to measure the natural size of the form
  const [scale, setScale] = useState(1);
  const [currentFormHeight, setCurrentFormHeight] = useState('auto'); // To adjust the height of the scaled content

  // Construct a mock GeneratedForm for preview if not yet generated by AI
  const getPreviewForm = (): GeneratedForm => {
    if (generatedForm) {
      return generatedForm;
    }

    // Default styling, potentially overridden by extracted tokens
    const defaultStyling = {
      primaryColor: extractedDesignTokens?.primaryColors?.[0] || '#007bff', /* Blue */
      backgroundColor: extractedDesignTokens?.colorPalette?.find(color => isLightColor(color)) || '#ffffff', /* White */
      fontFamily: extractedDesignTokens?.fontFamilies?.[0] || 'Inter, system-ui, -apple-system, sans-serif',
      borderRadius: '8px',
      buttonStyle: 'solid',
      // Removed maxWidth from here, let the parent container manage it
    };

    // Mock fields based on purpose
    let mockFields: FormField[] = [
      { type: 'email', name: 'email', label: 'Email Address', placeholder: 'Enter your email', required: true },
      { type: 'text', name: 'name', label: 'Name', placeholder: 'Your name', required: false },
    ];

    if (purpose?.toLowerCase().includes('feedback') || purpose?.toLowerCase().includes('message')) {
      mockFields.push({ type: 'textarea', name: 'message', label: 'Message', placeholder: 'Your message', required: true });
    } else if (purpose?.toLowerCase().includes('lead')) {
      mockFields.push({ type: 'text', name: 'company', label: 'Company', placeholder: 'Your company', required: false });
    }

    // Use extracted messaging for description if available
    const descriptionText = extractedDesignTokens?.messaging?.[0] || 
                            (url ? `This form will adapt to the style of ${url}` : 'Start by entering a website URL.');

    return {
      title: purpose ? `AI Form: ${purpose}` : 'Customer feedback', // Default title for preview
      description: descriptionText,
      fields: mockFields,
      ctaText: purpose?.toLowerCase().includes('subscribe') ? 'Subscribe' : 'Submit',
      thankYouMessage: 'Thank you for your submission!',
      styling: defaultStyling,
      // formLayout: 'inline', // Default to inline as other layouts are removed
    };
  };

  const previewForm = getPreviewForm();

  useEffect(() => {
    // This effect needs to run after the form content has rendered at its natural size
    // A small delay might be necessary to ensure DOM is fully updated
    const timer = setTimeout(() => {
      if (previewContainerRef.current && formNaturalSizeRef.current) {
        const containerHeight = previewContainerRef.current.clientHeight; // Available height of the fixed container
        const contentNaturalHeight = formNaturalSizeRef.current.scrollHeight; // Natural height of the form content
        const containerWidth = previewContainerRef.current.clientWidth; // Available width of the fixed container
        const contentNaturalWidth = formNaturalSizeRef.current.scrollWidth; // Natural width of the form content

        let newScale = 1;
        if (contentNaturalHeight > containerHeight || contentNaturalWidth > containerWidth) {
          const scaleY = containerHeight / contentNaturalHeight;
          const scaleX = containerWidth / contentNaturalWidth;
          newScale = Math.min(scaleY, scaleX); // Scale down to fit both dimensions
        }
        
        setScale(newScale);
        // Set the height of the scaled content wrapper to its scaled natural height
        setCurrentFormHeight(`${contentNaturalHeight * newScale}px`);
      }
    }, 50); // Small delay to allow DOM to settle

    return () => clearTimeout(timer);
  }, [previewForm, generatedForm, createdForm]); // Re-run when form data changes

  const formContent = (
    <EmbeddableForm
      form={previewForm}
      embedCode={createdForm?.embed_code || "preview-mode"}
      showBranding={false}
      onSubmit={(data) => console.log('Preview submission:', data)}
    />
  );

  const getDestinationText = () => {
    if (!destinationType) return '';
    switch (destinationType) {
      case 'email': return 'Email';
      case 'googlesheets': return 'Google Sheets';
      case 'slack': return 'Slack';
      case 'webhook': return 'Webhook';
      default: return '';
    }
  };

  return (
    <div className="card live-preview-card">
      <div className="preview-header">
        <h3>Live Form Preview</h3>
        {url && <p>Styled with design tokens from: {url}</p>}
      </div>
      
      <div className="live-preview-content-wrapper">
        {/* This div is to measure the natural size of the form before scaling */}
        <div
          ref={formNaturalSizeRef}
          style={{
            position: 'absolute',
            visibility: 'hidden',
            pointerEvents: 'none',
            width: '100%',
          }}
        >
          {formContent}
          {destinationType && (
            <div className="form-submit-status">
              <CheckCircle size={16} /> Data will be sent to: {getDestinationText()}
            </div>
          )}
        </div>

        {/* This div applies the scaling and is visible */}
        <div
          style={{
            transform: `scale(${scale})`,
            transformOrigin: 'top center',
            width: '100%',
            height: currentFormHeight,
            display: 'flex',
            justifyContent: 'center',
            alignItems: 'center',
            flexShrink: 0,
            flexDirection: 'column', // Allow content to stack
          }}
        >
          {url || purpose || generatedForm ? (
            <>
              {formContent}
              {destinationType && (
                <div className="form-submit-status">
                  <CheckCircle size={16} /> Data will be sent to: {getDestinationText()}
                </div>
              )}
            </>
          ) : (
            <div style={{ textAlign: 'center', padding: '20px', color: '#666' }}>
              <div className="sparkle-icon">✨</div>
              <h4 style={{ fontSize: '18px', marginBottom: '8px', color: '#333' }}>Your AI-Powered Form</h4>
              <p className="placeholder-text">
                Start by entering a website URL in the chat to the left to generate your form!
              </p>
            </div>
          )}
        </div>
      </div>
      {generatedForm && (
        <div className="ai-generated-badge">
          ✅ AI-generated form preview.
        </div>
      )}
    </div>
  );
};